From 56c7d5cdfd229d4c6ab7721580b72579df4b12a4 Mon Sep 17 00:00:00 2001
From: Guilherme Brondani Torri <guitorri@gmail.com>
Date: Thu, 16 Jul 2015 20:34:03 +0200
Subject: [PATCH] [bsim6] Fix T0 variable name collision

This can be resolved with adoption of namespaces per modules.
---
 bsim6.va | 326 +++++++++++++++++++++++++++++++--------------------------------
 1 file changed, 163 insertions(+), 163 deletions(-)

diff --git a/bsim6.va b/bsim6.va
index 725f32d..49b0c86 100755
--- a/bsim6.va
+++ b/bsim6.va
@@ -88,9 +88,9 @@
 	T8 = 0.5*( psip+1.0 + sqrt((psip-1.0)*(psip-1.0) + 0.25*2*2 ) ); \
 	sqrtpsip = sqrt(T8); \
 	T9 = 1.0+ gam/(2.0*sqrtpsip); \
-	T0 = ( 1.0+ (gam/(2.0*sqrtpsip)) )/gam; \
+	T_0 = ( 1.0+ (gam/(2.0*sqrtpsip)) )/gam; \
 	T1 = psip - 2.0*phib -vch; \
-	T2 = T1 - ln(4.0*T0*sqrtpsip); \
+	T2 = T1 - ln(4.0*T_0*sqrtpsip); \
 	T8 = 0.5*(T2 - 0.201491 - sqrt(T2 * (T2 + 0.402982) + 2.446562)); \
 	sqrtpsisa = sqrtpsip; \
 	if (T8 <= -68.0) begin \
@@ -107,17 +107,17 @@
 				T3 = exp(T4 + T5 * ((5.0/64.0) + 0.5*T2 + T6*( (15.0/16.0) - T6*(1.25 - T6)))); \
 			end \
 		end \
-		q = T3 * (1.0 + T1 - T8 -ln(2.0*T0*(T3*2.0*T0+2.0*sqrtpsisa))); \
+		q = T3 * (1.0 + T1 - T8 -ln(2.0*T_0*(T3*2.0*T_0+2.0*sqrtpsisa))); \
 	end else begin \
 		T3 = exp(T8); \
 		sqrtpsisainv = 1.0 / sqrtpsisa; \
-		T4 = 2.0*T3 + ln(T3*2.0*T0*(T3*2.0*T0+2.0*sqrtpsisa)) - T1; \
-		T5 = 2.0 + (1.0/T3) + (T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa); \
+		T4 = 2.0*T3 + ln(T3*2.0*T_0*(T3*2.0*T_0+2.0*sqrtpsisa)) - T1; \
+		T5 = 2.0 + (1.0/T3) + (T_0 - sqrtpsisainv)/(T_0*T3 + sqrtpsisa); \
 		T3 = T3 - T4/T5; \
-		T4 = 2.0*T3 + ln(T3*2.0*T0*(T3*2.0*T0+2.0*sqrtpsisa)) - T1; \
-		T5 = 2.0 + (1.0/T3) + (T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa); \
-		T6 = ((T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa))*((T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa)); \
-		T7 = -((1.0/T3)*(1.0/T3)) -(1.0/(sqrtpsisa*sqrtpsisa*sqrtpsisa*(T0*T3+sqrtpsisa))) - T6; \
+		T4 = 2.0*T3 + ln(T3*2.0*T_0*(T3*2.0*T_0+2.0*sqrtpsisa)) - T1; \
+		T5 = 2.0 + (1.0/T3) + (T_0 - sqrtpsisainv)/(T_0*T3 + sqrtpsisa); \
+		T6 = ((T_0 - sqrtpsisainv)/(T_0*T3 + sqrtpsisa))*((T_0 - sqrtpsisainv)/(T_0*T3 + sqrtpsisa)); \
+		T7 = -((1.0/T3)*(1.0/T3)) -(1.0/(sqrtpsisa*sqrtpsisa*sqrtpsisa*(T_0*T3+sqrtpsisa))) - T6; \
 		q = T3 - (T4/T5)*( 1.0 + T4*T7/(2.0*T5*T5)); \
 	end \
 
@@ -397,17 +397,17 @@
 `define BSIM6PAeffGeo(nf, geo, minSD,Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad) \
 	begin if (geo < 9) \
 			`BSIM6NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
-	T0 = DMCG + DMCI;\
+	T_0 = DMCG + DMCI;\
 	T1 = DMCG + DMCG;\
 	T2 = DMDG + DMDG;\
-	PSiso = T0 + T0 + Weffcj;\
-	PDiso = T0 + T0 + Weffcj;\
+	PSiso = T_0 + T_0 + Weffcj;\
+	PDiso = T_0 + T_0 + Weffcj;\
 	PSsha = T1;\
 	PDsha = T1;\
 	PSmer = T2;\
 	PDmer = T2;\
-	ASiso = T0 * Weffcj;\
-	ADiso = T0 * Weffcj;\
+	ASiso = T_0 * Weffcj;\
+	ADiso = T_0 * Weffcj;\
 	ASsha = DMCG * Weffcj;\
 	ADsha = DMCG * Weffcj;\
 	ASmer = DMDG * Weffcj;	\
@@ -1546,7 +1546,7 @@ parameter real GMIN		= $simparam("gmin", 1.0e-15);
 
 // Common Variables
 real PSiso,PDiso,PSsha,PDsha,PSmer,PDmer,ASiso,ADiso,ASsha,ADsha,ASmer,ADmer;
-real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
+real T_0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
 real Tb;
 real epssi, epsox, ni, Weff, Leff, Weff1, Leff1, Wact, Lact, Weffcj, Eg, Eg0;
 real dLIV, dWIV, dLB, dWB, dLCV, dWCV, dWJ, Cox, epsratio;
@@ -2067,13 +2067,13 @@ analog begin
 	PSATB_i		= PSATB 	+ BIN_L * LPSATB 	+ BIN_W * WPSATB	+ BIN_WL * PPSATB;
 
 	// Geometrical scaling
-	T0 = NDEPL1 * max( pow(Inv_L, NDEPLEXP1) - pow(Inv_Llong, NDEPLEXP1), 0) + NDEPL2 * max( pow(Inv_L, NDEPLEXP2) - pow(Inv_Llong, NDEPLEXP2), 0);
+	T_0 = NDEPL1 * max( pow(Inv_L, NDEPLEXP1) - pow(Inv_Llong, NDEPLEXP1), 0) + NDEPL2 * max( pow(Inv_L, NDEPLEXP2) - pow(Inv_Llong, NDEPLEXP2), 0);
 	T1 = NDEPW * max( pow(Inv_W, NDEPWEXP) - pow(Inv_Wwide, NDEPWEXP), 0) + NDEPWL * pow(Inv_W * Inv_L, NDEPWLEXP);
-	NDEP_i = NDEP_i * (1.0 + T0 + T1);
+	NDEP_i = NDEP_i * (1.0 + T_0 + T1);
 
-	T0 = NFACTORL * max( pow(Inv_L, NFACTORLEXP) - pow(Inv_Llong, NFACTORLEXP), 0);
+	T_0 = NFACTORL * max( pow(Inv_L, NFACTORLEXP) - pow(Inv_Llong, NFACTORLEXP), 0);
 	T1 = NFACTORW * max( pow(Inv_W, NFACTORWEXP) - pow(Inv_Wwide, NFACTORWEXP), 0) + NFACTORWL * pow(Inv_WL, NFACTORWLEXP);
-	NFACTOR_i = NFACTOR_i * (1.0 + T0 + T1);
+	NFACTOR_i = NFACTOR_i * (1.0 + T_0 + T1);
 
 	CDSCD_i = CDSCD_i * (1.0 + CDSCDL * max( pow(Inv_L, CDSCDLEXP) - pow(Inv_Llong, CDSCDLEXP), 0) );
 	CDSCB_i = CDSCB_i * (1.0 + CDSCBL * max( pow(Inv_L, CDSCBLEXP) - pow(Inv_Llong, CDSCBLEXP), 0) );
@@ -2083,33 +2083,33 @@ analog begin
 	end else
 		U0_i = U0_i * (1.0 - U0L);
 
-	T0 = UAL * max( pow(Inv_L, UALEXP) - pow(Inv_Llong, UALEXP), 0);
+	T_0 = UAL * max( pow(Inv_L, UALEXP) - pow(Inv_Llong, UALEXP), 0);
 	T1 = UAW * max( pow(Inv_W, UAWEXP) - pow(Inv_Wwide, UAWEXP), 0) + UAWL * pow(Inv_WL, UAWLEXP);
-	UA_i = UA_i * (1.0 + T0 + T1);
+	UA_i = UA_i * (1.0 + T_0 + T1);
 
-	T0 = EUL * max( pow(Inv_L, EULEXP) - pow(Inv_Llong, EULEXP), 0);
+	T_0 = EUL * max( pow(Inv_L, EULEXP) - pow(Inv_Llong, EULEXP), 0);
 	T1 = EUW * max( pow(Inv_W, EUWEXP) - pow(Inv_Wwide, EUWEXP), 0) + EUWL * pow(Inv_WL, EUWLEXP);
-	EU_i = EU_i * (1.0 + T0 + T1);
+	EU_i = EU_i * (1.0 + T_0 + T1);
 
 	UD_i = UD_i * (1.0 + UDL * max( pow(Inv_L, UDLEXP) - pow(Inv_Llong, UDLEXP), 0));
-	T0 = UCL * max( pow(Inv_L, UCLEXP) - pow(Inv_Llong, UCLEXP), 0);
+	T_0 = UCL * max( pow(Inv_L, UCLEXP) - pow(Inv_Llong, UCLEXP), 0);
 	T1 = UCW * max( pow(Inv_W, UCWEXP) - pow(Inv_Wwide, UCWEXP), 0) + UCWL * pow(Inv_WL, UCWLEXP);
-	UC_i = UC_i * (1.0 + T0 + T1);
+	UC_i = UC_i * (1.0 + T_0 + T1);
 
 	ETA0_i = ETA0_i * max( pow(Inv_L, DSUB) - pow(Inv_Llong, DSUB), 0);
 	ETAB_i = ETAB_i * max( pow(Inv_L, ETABEXP) - pow(Inv_Llong, ETABEXP), 0);
 	PDIBLC_i = PDIBLC_i * ( 1.0 + PDIBLCL * max( pow(Inv_L, PDIBLCLEXP) - pow(Inv_Llong, PDIBLCLEXP), 0));
 
-	T0 = DELTA_i * (1.0 + DELTAL * max( pow(Inv_L, DELTALEXP) - pow(Inv_Llong, DELTALEXP), 0));
-	DELTA_i = min(T0, 0.5);
+	T_0 = DELTA_i * (1.0 + DELTAL * max( pow(Inv_L, DELTALEXP) - pow(Inv_Llong, DELTALEXP), 0));
+	DELTA_i = min(T_0, 0.5);
 
 	FPROUT_i = FPROUT_i * (1.0 + FPROUTL * max( pow(Inv_L, FPROUTLEXP) - pow(Inv_Llong, FPROUTLEXP), 0));
 	PCLM_i = PCLM_i * (1.0 + PCLML * max( pow(Inv_L, PCLMLEXP) - pow(Inv_Llong, PCLMLEXP), 0));
 	PCLM_i = max(PCLM_i,0);
 
-	T0 = VSATL * max( pow(Inv_L, VSATLEXP) - pow(Inv_Llong, VSATLEXP), 0);
+	T_0 = VSATL * max( pow(Inv_L, VSATLEXP) - pow(Inv_Llong, VSATLEXP), 0);
 	T1 = VSATW * max( pow(Inv_W, VSATWEXP) - pow(Inv_Wwide, VSATWEXP), 0) + VSATWL * pow(Inv_WL, VSATWLEXP);
-	VSAT_i = VSAT_i * (1.0 + T0 + T1);
+	VSAT_i = VSAT_i * (1.0 + T_0 + T1);
 
 	PSAT_i = max(PSAT_i * (1.0 + PSATL * max( pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0)), 0.25);
 	PTWG_i = PTWG_i * (1.0 + PTWGL * max( pow(Inv_L, PTWGLEXP) - pow(Inv_Llong, PTWGLEXP), 0));
@@ -2124,23 +2124,23 @@ analog begin
 	AIGD_i = AIGD_i * (1.0 + AIGDL * Inv_L + AIGDW * Inv_W);
 	PIGCD_i = PIGCD * (1.0 + PIGCDL * Inv_L);
 
-	T0 = NDEPCVL1 * max( pow(Inv_Lact, NDEPCVLEXP1) - pow(Inv_Llong, NDEPCVLEXP1), 0) + NDEPCVL2 * max( pow(Inv_Lact, NDEPCVLEXP2) - pow(Inv_Llong, NDEPCVLEXP2), 0);
+	T_0 = NDEPCVL1 * max( pow(Inv_Lact, NDEPCVLEXP1) - pow(Inv_Llong, NDEPCVLEXP1), 0) + NDEPCVL2 * max( pow(Inv_Lact, NDEPCVLEXP2) - pow(Inv_Llong, NDEPCVLEXP2), 0);
 	T1 = NDEPCVW * max( pow(Inv_Wact, NDEPCVWEXP) - pow(Inv_Wwide, NDEPCVWEXP), 0) + NDEPCVWL * pow(Inv_Wact * Inv_Lact, NDEPCVWLEXP);
-	NDEPCV_i = NDEPCV_i * (1.0 + T0 + T1);
+	NDEPCV_i = NDEPCV_i * (1.0 + T_0 + T1);
 
-	T0 = VFBCVL * max( pow(Inv_Lact, VFBCVLEXP) - pow(Inv_Llong, VFBCVLEXP), 0);
+	T_0 = VFBCVL * max( pow(Inv_Lact, VFBCVLEXP) - pow(Inv_Llong, VFBCVLEXP), 0);
 	T1 = VFBCVW * max( pow(Inv_Wact, VFBCVWEXP) - pow(Inv_Wwide, VFBCVWEXP), 0) + VFBCVWL * pow(Inv_WL, VFBCVWLEXP);
-	VFBCV_i = VFBCV_i * (1.0 + T0 + T1);
+	VFBCV_i = VFBCV_i * (1.0 + T_0 + T1);
 
-	T0 = VSATCVL * max( pow(Inv_Lact, VSATCVLEXP) - pow(Inv_Llong, VSATCVLEXP), 0);
+	T_0 = VSATCVL * max( pow(Inv_Lact, VSATCVLEXP) - pow(Inv_Llong, VSATCVLEXP), 0);
 	T1 = VSATCVW * max( pow(Inv_W, VSATCVWEXP) - pow(Inv_Wwide, VSATCVWEXP), 0) + VSATCVWL * pow(Inv_WL, VSATCVWLEXP);
-	VSATCV_i = VSATCV_i * (1.0 + T0 + T1);
+	VSATCV_i = VSATCV_i * (1.0 + T_0 + T1);
 	PCLMCV_i = PCLMCV_i * (1.0 + PCLMCVL * max( pow(Inv_Lact, PCLMCVLEXP) - pow(Inv_Llong, PCLMCVLEXP), 0));
 	PCLMCV_i = max(PCLMCV_i,0);
 
-	T0 = K2L * max( pow(Inv_L, K2LEXP) - pow(Inv_Llong, K2LEXP), 0);
+	T_0 = K2L * max( pow(Inv_L, K2LEXP) - pow(Inv_Llong, K2LEXP), 0);
 	T1 = K2W * max( pow(Inv_W, K2WEXP) - pow(Inv_Wwide, K2WEXP), 0) + K2WL * pow(Inv_WL, K2WLEXP);
-	K2_i = K2_i * (1.0 + T0 + T1);
+	K2_i = K2_i * (1.0 + T_0 + T1);
 
 	PRWB_i = PRWB_i * (1.0 + PRWBL * max( pow(Inv_L, PRWBLEXP) - pow(Inv_Llong, PRWBLEXP), 0));
 
@@ -2414,10 +2414,10 @@ analog begin
 		$strobe("[BSIM6] Although the model selector RGATEMOD is set to %d, the gate resistance model was not activated when the Verilog-A code was compiled.  Please uncomment \"`define __RGATEMOD__\" in the beginning of the Verilog-A code.", RGATEMOD);
 `endif
 
-	T0 = TOXE * TOXE;
+	T_0 = TOXE * TOXE;
 	T1 = TOXE * POXEDGE_i;
 	T2 = T1 * T1;
-	ToxRatio = exp(NTOX_i * ln(TOXREF / TOXE))/ T0;
+	ToxRatio = exp(NTOX_i * ln(TOXREF / TOXE))/ T_0;
 	ToxRatioEdge = exp(NTOX_i * ln(TOXREF / T1)) /T2;
 
 	Aechvb = (TYPE == `ntype) ? 4.97232e-7 : 3.42537e-7;
@@ -2447,8 +2447,8 @@ analog begin
 	//***** Temperature Dependent Calculations Begin Here *****//
 
 	if(TNOM <= -`P_CELSIUS0) begin
-		T0 = `REFTEMP - `P_CELSIUS0;
-		$strobe("Warning: TNOM = %e C <= %e C. Setting TNOM to %e C.", TNOM, -`P_CELSIUS0, T0);
+		T_0 = `REFTEMP - `P_CELSIUS0;
+		$strobe("Warning: TNOM = %e C <= %e C. Setting TNOM to %e C.", TNOM, -`P_CELSIUS0, T_0);
 		Tnom = `REFTEMP;
 	end else begin
 		Tnom = TNOM + `P_CELSIUS0;
@@ -2538,13 +2538,13 @@ analog begin
 	PBSWGS_t = hypsmooth(PBSWGS - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
 	PBSWGD_t = hypsmooth(PBSWGD - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
 
-	T0 = Eg0 / Vtm0 - Eg / Vtm;
+	T_0 = Eg0 / Vtm0 - Eg / Vtm;
 	T1 = lln(TRatio);
-	T3 = lexp((T0 + XTIS * T1) / NJS);
+	T3 = lexp((T_0 + XTIS * T1) / NJS);
 	JSS_t = JSS * T3;
 	JSWS_t = JSWS * T3;
 	JSWGS_t = JSWGS * T3;
-	T3 = lexp((T0 + XTID * T1) / NJD);
+	T3 = lexp((T_0 + XTID * T1) / NJD);
 	JSD_t = JSD * T3;
 	JSWD_t = JSWD * T3;
 	JSWGD_t = JSWGD * T3;
@@ -2619,9 +2619,9 @@ analog begin
 		T2 = max(IJTHSFWD / Isbs, 10.0);
 		Tb = 1.0 + T2 - XExpBVS;
 		VjsmFwd = Nvtms * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVS)));
-		T0 = lexp(VjsmFwd / Nvtms);
-		IVjsmFwd = Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
-		SslpFwd = Isbs * (T0 + XExpBVS / T0) / Nvtms;
+		T_0 = lexp(VjsmFwd / Nvtms);
+		IVjsmFwd = Isbs * (T_0 - XExpBVS / T_0 + XExpBVS - 1.0);
+		SslpFwd = Isbs * (T_0 + XExpBVS / T_0) / Nvtms;
 		T2 = hypsmooth(IJTHSREV / Isbs - 10.0, 1.0E-3) + 10.0;
 		VjsmRev = -BVS - Nvtms * lln((T2 - 1.0) / XJBVS);
 		T1 = XJBVS * lexp(-(BVS + VjsmRev) / Nvtms);
@@ -2646,9 +2646,9 @@ analog begin
 		T2 = max(IJTHDFWD / Isbd, 10.0);
 		Tb = 1.0 + T2 - XExpBVD;
 		VjdmFwd = Nvtmd * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVD)));
-		T0 = lexp(VjdmFwd / Nvtmd);
-		IVjdmFwd = Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
-		DslpFwd = Isbd * (T0 + XExpBVD / T0) / Nvtmd;
+		T_0 = lexp(VjdmFwd / Nvtmd);
+		IVjdmFwd = Isbd * (T_0 - XExpBVD / T_0 + XExpBVD - 1.0);
+		DslpFwd = Isbd * (T_0 + XExpBVD / T_0) / Nvtmd;
 		T2 = hypsmooth(IJTHDREV / Isbd - 10.0, 1.0E-3) + 10.0;
 		VjdmRev = -BVD - Nvtmd * lln((T2 - 1.0) / XJBVD);
 		T1 = XJBVD * lexp(-(BVD + VjdmRev) / Nvtmd);
@@ -2676,28 +2676,28 @@ analog begin
 	//STI Stress Equations
 
 	if (KU0 !=0 || KVSAT !=0 || KVTH0 !=0 || STK2 !=0 || STETA0 !=0) begin
-		T0 = pow(Lnew, LLODKU0);
+		T_0 = pow(Lnew, LLODKU0);
 		
 		W_tmp_stress = Wnew + WLOD;
 
 		T1 = pow(W_tmp_stress, WLODKU0);
-		tmp1_stress = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);
+		tmp1_stress = LKU0 / T_0 + WKU0 / T1 + PKU0 / (T_0 * T1);
 
 		kstress_u0 = 1.0 + tmp1_stress;
 
-		T0 = pow(Lnew, LLODVTH);
+		T_0 = pow(Lnew, LLODVTH);
 		T1 = pow(W_tmp_stress, WLODVTH);
-		tmp1_stress_vth = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
+		tmp1_stress_vth = LKVTH0 / T_0 + WKVTH0 / T1 + PKVTH0 / (T_0 * T1);
 		kstress_vth0 = 1.0 + tmp1_stress_vth;
 
-		T0 = (TRatio - 1.0);
-		ku0_temp = kstress_u0 * (1.0 + TKU0 * T0) + 1.0e-9;
+		T_0 = (TRatio - 1.0);
+		ku0_temp = kstress_u0 * (1.0 + TKU0 * T_0) + 1.0e-9;
 
 		Inv_sa = 0;	Inv_sb = 0;//Initialization of for loop
 		for (i = 0; i < NF; i = i+1) begin : forloop
-			T0 = 1.0 / NF / (SA + 0.5*L_mult + i * (SD +L_mult));
+			T_0 = 1.0 / NF / (SA + 0.5*L_mult + i * (SD +L_mult));
 			T1 = 1.0 / NF / (SB + 0.5*L_mult + i * (SD +L_mult));
-			Inv_sa = Inv_sa + T0;
+			Inv_sa = Inv_sa + T_0;
 			Inv_sb = Inv_sb + T1;
 		end
 
@@ -2796,11 +2796,11 @@ analog begin
 
 	/* Vth correction for Pocket implant*/
 	if (DVTP0_i > 0.0) begin
-		T0 = -DVTP1_i * Vdsx;
-		if (T0 < -`EXPL_THRESHOLD)
+		T_0 = -DVTP1_i * Vdsx;
+		if (T_0 < -`EXPL_THRESHOLD)
 			T2 = `MIN_EXPL;
 		else
-			T2 = exp(T0);
+			T2 = exp(T_0);
 		T3 = Leff + DVTP0_i * (1.0 + T2);
 		dVth_ldop = -nVt * lln(Leff / T3);
 	end else
@@ -2833,14 +2833,14 @@ analog begin
 	`Smooth(psip, 1.0, 2.0, psipclamp)
 	sqrtpsip = sqrt(psipclamp);
 	psiavg 	 = psip - 2.0*qs; // source side surf pot.
-	`Smooth(psiavg, 1.0, 2.0, T0)
-	nq 		 = 1.0 + gam / (sqrtpsip + sqrt(T0));
+	`Smooth(psiavg, 1.0, 2.0, T_0)
+	nq 		 = 1.0 + gam / (sqrtpsip + sqrt(T_0));
 
 	// *** Drain Saturation Voltage ***
 	EeffFactor = 1.0e-8 / (epsratio * TOXE);
 
-	T0 = nVt * (vgfb - psip - 2.0*qs*(nq-1.0));
-	`Smooth(T0, 0, 0.1, qbs)
+	T_0 = nVt * (vgfb - psip - 2.0*qs*(nq-1.0));
+	`Smooth(T_0, 0, 0.1, qbs)
 	qis = 2.0 * nq * nVt * qs; //Source side qi and qb for Vdsat- normalized to Cox
 
 	Eeffs = EeffFactor * (qbs + eta_mu * qis); // in the unit of MV/cm
@@ -2857,9 +2857,9 @@ analog begin
 		Rdss = 0.0;
 	else begin
 `endif
-		T0 = 1.0 + PRWG_i * qis;
+		T_0 = 1.0 + PRWG_i * qis;
 		T1 = PRWB_i*(sqrtPhistVbs - sqrtPhist);
-		T2 = 1.0 / T0 + T1;
+		T2 = 1.0 / T_0 + T1;
 		T3 = T2 + sqrt(T2*T2 + 0.01);
 		Rdss = (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF * rdstemp;
 		
@@ -2869,7 +2869,7 @@ analog begin
 	end
 `endif
 
-	T0			= pow(Dmobs, 1.0/PSAT_i);
+	T_0			= pow(Dmobs, 1.0/PSAT_i);
 	if (PSATB_i<0)
 		T1		= 1.0 / (1.0 + PSATB_i * Vbsx);
 	else
@@ -2877,14 +2877,14 @@ analog begin
 
 	T2			= 10.0 *PSATX * qs * T1 / (10.0 *PSATX + qs * T1);
 	if (PTWG_t<0)
-		LambdaC = 2.0 * ((U0_t / T0) * nVt / (VSAT_t * Leff)) * (1.0/(1.0-PTWG_t*T2));
+		LambdaC = 2.0 * ((U0_t / T_0) * nVt / (VSAT_t * Leff)) * (1.0/(1.0-PTWG_t*T2));
 	else
-		LambdaC = 2.0 * ((U0_t / T0) * nVt / (VSAT_t * Leff)) * (1.0 + PTWG_t*T2);
+		LambdaC = 2.0 * ((U0_t / T_0) * nVt / (VSAT_t * Leff)) * (1.0 + PTWG_t*T2);
 
 	if (Rdss==0) begin// qdsat for external Rds
 		// Accurate qdsat derived from consistent I-V
-		T0 = 0.5 * LambdaC * (qs*qs + qs) / (1.0 + 0.5 * LambdaC *(1.0 + qs));
-		T1 = 2.0 * LambdaC * (qs - T0);
+		T_0 = 0.5 * LambdaC * (qs*qs + qs) / (1.0 + 0.5 * LambdaC *(1.0 + qs));
+		T1 = 2.0 * LambdaC * (qs - T_0);
 		T2 = sqrt(1.0 + T1*T1);
 		ln_T1_T2 = asinh(T1);//used VA function for asinh(T1)=ln(T1 + T2)
 		if (T1 != 0)
@@ -2892,16 +2892,16 @@ analog begin
 		else
 			T3 =   T2 + (1.0/T2);
 
-		T4 = T0 * T3 - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
+		T4 = T_0 * T3 - LambdaC * ((qs*qs + qs) - (T_0*T_0 + T_0) );
 		if (T1 != 0)
 			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
 		else
 			T5 = (-2.0 * LambdaC) * (T1/T2) * (T1/T2) *(T1/T2);
 
-		T6 = T0 * T5 + T3 + LambdaC * (2.0*T0 + 1.0);
-		T0 = T0 - (T4/T6);
+		T6 = T_0 * T5 + T3 + LambdaC * (2.0*T_0 + 1.0);
+		T_0 = T_0 - (T4/T6);
 
-		T1 = 2.0 * LambdaC * (qs - T0);
+		T1 = 2.0 * LambdaC * (qs - T_0);
 		T2 = sqrt(1.0 + T1*T1);
 		ln_T1_T2 = asinh(T1);
 		if (T1 != 0)
@@ -2909,21 +2909,21 @@ analog begin
 		else
 			T3 =   T2 + (1.0/T2);
 
-		T4 = T0 * T3 - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
+		T4 = T_0 * T3 - LambdaC * ((qs*qs + qs) - (T_0*T_0 + T_0) );
 		if (T1 != 0)
 			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
 		else
 			T5 = (T1/T2) * (T1/T2) *(T1/T2);
 
-		T6 = T0 * T5 + T3 + LambdaC * (2.0*T0 + 1.0);
-		qdsat = T0 - (T4/T6);
+		T6 = T_0 * T5 + T3 + LambdaC * (2.0*T_0 + 1.0);
+		qdsat = T_0 - (T4/T6);
 
 	end else begin // qdsat for internal Rds -- Ref. : BSIM4 model
 		// Accurate qdsat derived from consistent I-V
 		T11 = Weff * 2.0 * nq * Cox * nVt * VSAT_t;
 		T12 = T11 * LambdaC * Rdss / (2.0*nVt);
-		T0  = 0.5 * LambdaC * (qs*qs + qs) / (1.0 + 0.5 * LambdaC *(1.0 + qs));
-		T1  = 2.0 * LambdaC * (qs - T0);
+		T_0  = 0.5 * LambdaC * (qs*qs + qs) / (1.0 + 0.5 * LambdaC *(1.0 + qs));
+		T1  = 2.0 * LambdaC * (qs - T_0);
 		T2  = sqrt(1.0 + T1*T1);
 		ln_T1_T2 = asinh(T1);//used VA function for asinh(T1)=ln(T1 + T2)
 		if (T1 != 0)
@@ -2931,16 +2931,16 @@ analog begin
 		else
 			T3 =   T2 + (1.0/T2);
 
-		T4  = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
+		T4  = T_0 * T3 + T12 * T_0 * (qs + T_0 + 1.0) - LambdaC * ((qs*qs + qs) - (T_0*T_0 + T_0) );
 		if (T1 != 0)
 			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
 		else
 			T5 = (-2.0 * LambdaC) * (T1/T2) * (T1/T2) *(T1/T2);
 
-		T6  = T0 * T5 + T3 + T12 * (qs + 2.0*T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
-		T0  = T0 - T4/T6;
+		T6  = T_0 * T5 + T3 + T12 * (qs + 2.0*T_0 + 1.0) + LambdaC * (2.0 * T_0 + 1.0);
+		T_0  = T_0 - T4/T6;
 
-		T1  = 2.0 * LambdaC * (qs - T0);
+		T1  = 2.0 * LambdaC * (qs - T_0);
 		T2  = sqrt(1.0 + T1*T1);
 		ln_T1_T2 = asinh(T1);
 		if (T1 != 0)
@@ -2948,14 +2948,14 @@ analog begin
 		else
 			T3 =   T2 + (1.0/T2);
 
-		T4  = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
+		T4  = T_0 * T3 + T12 * T_0 * (qs + T_0 + 1.0) - LambdaC * ((qs*qs + qs) - (T_0*T_0 + T_0) );
 		if (T1 != 0)
 			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
 		else
 			T5 = (-2.0 * LambdaC) * (T1/T2) * (T1/T2) *(T1/T2);
 
-		T6  = T0 * T5 + T3 + T12 * (qs + 2.0*T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
-		qdsat  = T0 - T4/T6;
+		T6  = T_0 * T5 + T3 + T12 * (qs + 2.0*T_0 + 1.0) + LambdaC * (2.0 * T_0 + 1.0);
+		qdsat  = T_0 - T4/T6;
 	end
 
 	vdsat 	= psip -2.0*phib_n - (2.0*qdsat + ln( (qdsat*2.0*nq*inv_gam)*((qdsat*2.0*nq*inv_gam) + (gam/(nq-1.0)) ) ));
@@ -2972,16 +2972,16 @@ analog begin
 	//*********************************************************
 	// Reevaluation of nq to include qdeff --needed for gummel symmetry
 	psiavg = psip - qs - qdeff -1.0;
-	`Smooth(psiavg, 1.0, 2.0, T0)
-	T2 = sqrt(T0);
+	`Smooth(psiavg, 1.0, 2.0, T_0)
+	T2 = sqrt(T_0);
 	nq = 1.0 + gam/(sqrtpsip+T2);
 	//Inversion and bulk charge
 	DQSD2 = (qs-qdeff)*(qs-qdeff);
-	T0 = 1.0 / (1.0 + qs + qdeff);
-	T1 = DQSD2 * T0;
+	T_0 = 1.0 / (1.0 + qs + qdeff);
+	T1 = DQSD2 * T_0;
 	Qb = vgfb -psip - (nq-1.0)*( qs + qdeff + `Oneby3 * T1);
 	T2 = `Oneby3*nq;
-	T3 = T1*T0;
+	T3 = T1*T_0;
 	Qs = T2*( 2.0*qs + qdeff + 0.5*(1.0+0.8*qs+1.2*qdeff)*T3);
 	Qd = T2*( qs + 2.0*qdeff + 0.5*(1.0+1.2*qs+0.8*qdeff)*T3);
 	//*********************************************************
@@ -3048,14 +3048,14 @@ analog begin
 		VaDITS 	= `MAX_EXPL;
 
 	T4  = diffVds / VaDITS;
-	T0  = 1.0 + T4;
-	Moc = Moc * T0;
+	T_0  = 1.0 + T4;
+	Moc = Moc * T_0;
 
 	// Calculate Vascbe -- Ref BSIM4
 	if (PSCBE2_i > 0.0) begin
 		if (diffVds > PSCBE1_i * litl / `EXPL_THRESHOLD) begin
-			T0 		= PSCBE1_i * litl / diffVds;
-			VaSCBE 	= Leff * exp(T0) / PSCBE2_i;
+			T_0 		= PSCBE1_i * litl / diffVds;
+			VaSCBE 	= Leff * exp(T_0) / PSCBE2_i;
 		end else
 			VaSCBE 	= `MAX_EXPL * Leff/PSCBE2_i;
 	end else
@@ -3065,7 +3065,7 @@ analog begin
 	Moc = Moc * Mscbe;
 
 	// *** Velocity Saturation ***
-	T0			= pow(Dmob, 1.0/PSAT_i);
+	T_0			= pow(Dmob, 1.0/PSAT_i);
 	if (PSATB_i<0)
 		T1		= 1.0 / (1.0 + PSATB_i * Vbsx);
 	else
@@ -3073,9 +3073,9 @@ analog begin
 
 	T2			= 10.0* PSATX * qia * T1 / (10.0 *PSATX + qia * T1);
 	if (PTWG_t<0)
-		LambdaC = 2.0 * ((U0_t / T0) * nVt / (VSAT_t * Leff)) * (1.0/(1.0- PTWG_t * T2));
+		LambdaC = 2.0 * ((U0_t / T_0) * nVt / (VSAT_t * Leff)) * (1.0/(1.0- PTWG_t * T2));
 	else
-		LambdaC = 2.0 * ((U0_t / T0) * nVt / (VSAT_t * Leff)) * (1.0 + PTWG_t * T2);
+		LambdaC = 2.0 * ((U0_t / T_0) * nVt / (VSAT_t * Leff)) * (1.0 + PTWG_t * T2);
 
 	T1			= 2.0 * LambdaC * (qs - qdeff);
 	T2			= sqrt(1.0 + T1 * T1);
@@ -3116,9 +3116,9 @@ analog begin
 `endif
 		// Ref: (1) BSIM4 Model
 		//      (2) "Operation and Modeling of the MOS Transistor" by Yannis Tsividis
-		T0 = 1.0 + PRWG_i * qia;//reevaluate for gummel symmetry
+		T_0 = 1.0 + PRWG_i * qia;//reevaluate for gummel symmetry
 		T1 = PRWB_i*(sqrtPhistVbs - sqrtPhist);
-		T2 = 1.0 / T0 + T1;
+		T2 = 1.0 / T_0 + T1;
 		T3 = 0.5 * (T2 + sqrt(T2*T2 + 0.01));
 		Rdsi = rdstemp * (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF ;
 		Rdrain = RDrainGeo;
@@ -3155,8 +3155,8 @@ analog begin
 		//idsovvds= ueff*Weff/Leff*Cox*qia*Moc;
 		idsovvds= ueff*Weff/Leff*Cox*qia;
 		T9 = XRCRG2 * Vt;
-		T0 = T9 * ueff * Weff/Leff * Cox;
-		Gcrg = XRCRG1 * NF * (T0 + idsovvds);
+		T_0 = T9 * ueff * Weff/Leff * Cox;
+		Gcrg = XRCRG1 * NF * (T_0 + idsovvds);
 		if (RGATEMOD == 2) begin
 			T11 = Grgeltd + Gcrg;
 			Gcrg = Grgeltd * Gcrg / T11;
@@ -3267,12 +3267,12 @@ analog begin
 	igisl = 0.0;
 	igidl = 0.0;
 	if (GIDLMOD != 0) begin
-		T0 = epsratio * TOXE;
+		T_0 = epsratio * TOXE;
 		// GIDL
 		if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0) || (CGIDL_i < 0.0)) begin
 			T6 = 0.0;
 		end else begin
-			T1 = (- Vgd_noswap - EGIDL_i + Vfbsdr) / T0;
+			T1 = (- Vgd_noswap - EGIDL_i + Vfbsdr) / T_0;
 			T1 =  hypsmooth(T1, 1.0E-2);
 			T2 = BGIDL_t / (T1 + 1.0E-3);
 			if (CGIDL_i !=0) begin
@@ -3289,7 +3289,7 @@ analog begin
 		if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0) || (CGISL_i < 0.0)) begin
 			T6 = 0.0;
 		end else begin
-			T1 = (- Vgs_noswap - EGISL_i + Vfbsdr) / T0;
+			T1 = (- Vgs_noswap - EGISL_i + Vfbsdr) / T_0;
 			T1 =  hypsmooth(T1, 1.0E-2);
 			T2 = BGISL_t / (T1 + 1.0E-3);
 			if (CGISL_i !=0) begin
@@ -3310,15 +3310,15 @@ analog begin
 	// Source-side junction current
 	if(Isbs > 0.0) begin
 		if (Vbs_jct < VjsmRev) begin
-			T0 = Vbs_jct / Nvtms;
-			T1 = lexp(T0) - 1.0;
+			T_0 = Vbs_jct / Nvtms;
+			T1 = lexp(T_0) - 1.0;
 			T2 = IVjsmRev + SslpRev * (Vbs_jct - VjsmRev);
 			Ibs = T1 * T2;
 		end else if (Vbs_jct <= VjsmFwd) begin
-			T0 = Vbs_jct / Nvtms;
+			T_0 = Vbs_jct / Nvtms;
 			T1 = (BVS + Vbs_jct) / Nvtms;
 			T2 = lexp(-T1);
-			Ibs = Isbs * (lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
+			Ibs = Isbs * (lexp(T_0) + XExpBVS - 1.0 - XJBVS * T2);
 		end else
 			Ibs = IVjsmFwd + SslpFwd * (Vbs_jct - VjsmFwd);
 	end else
@@ -3327,34 +3327,34 @@ analog begin
 	//Source-side junction tunneling current
 	if(JTSS_t > 0.0) begin
 		if((VTSS - Vbs_jct) < (VTSS * 1.0e-3)) begin
-			T0 = -Vbs_jct / Vtm0 / NJTS_t;
-			T1 = lexp(T0 * 1.0e+3) - 1.0;
+			T_0 = -Vbs_jct / Vtm0 / NJTS_t;
+			T1 = lexp(T_0 * 1.0e+3) - 1.0;
 			Ibs = Ibs - ASeff * JTSS_t * T1;
 		end else begin
-			T0 = -Vbs_jct / Vtm0 / NJTS_t;
-			T1 = lexp(T0 * VTSS / (VTSS - Vbs_jct)) - 1.0;
+			T_0 = -Vbs_jct / Vtm0 / NJTS_t;
+			T1 = lexp(T_0 * VTSS / (VTSS - Vbs_jct)) - 1.0;
 			Ibs = Ibs - ASeff * JTSS_t * T1;
 		end
 	end
 	if(JTSSWS_t > 0.0) begin
 		if((VTSSWS - Vbs_jct) < (VTSSWS * 1.0e-3)) begin
-			T0 = -Vbs_jct / Vtm0 / NJTSSW_t;
-			T1 = lexp(T0 * 1.0e+3) - 1.0;
+			T_0 = -Vbs_jct / Vtm0 / NJTSSW_t;
+			T1 = lexp(T_0 * 1.0e+3) - 1.0;
 			Ibs = Ibs - PSeff * JTSSWS_t * T1;
 		end else begin
-			T0 = -Vbs_jct / Vtm0 / NJTSSW_t;
-			T1 = lexp(T0 * VTSSWS / (VTSSWS - Vbs_jct)) - 1.0;
+			T_0 = -Vbs_jct / Vtm0 / NJTSSW_t;
+			T1 = lexp(T_0 * VTSSWS / (VTSSWS - Vbs_jct)) - 1.0;
 			Ibs = Ibs - PSeff * JTSSWS_t * T1;
 		end
 	end
 	if(JTSSWGS_t > 0.0) begin
 		if((VTSSWGS - Vbs_jct) < (VTSSWGS * 1.0e-3)) begin
-			T0 = -Vbs_jct / Vtm0 / NJTSSWG_t;
-			T1 = lexp(T0 * 1.0e+3) - 1.0;
+			T_0 = -Vbs_jct / Vtm0 / NJTSSWG_t;
+			T1 = lexp(T_0 * 1.0e+3) - 1.0;
 			Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
 		end else begin
-			T0 = -Vbs_jct / Vtm0 / NJTSSWG_t;
-			T1 = lexp(T0 * VTSSWGS / (VTSSWGS - Vbs_jct)) - 1.0;
+			T_0 = -Vbs_jct / Vtm0 / NJTSSWG_t;
+			T1 = lexp(T_0 * VTSSWGS / (VTSSWGS - Vbs_jct)) - 1.0;
 			Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
 		end
 	end
@@ -3363,15 +3363,15 @@ analog begin
 	// Drain-side junction current
 	if(Isbd > 0.0) begin
 		if (Vbd_jct < VjdmRev) begin
-			T0 = Vbd_jct / Nvtmd;
-			T1 = lexp(T0) - 1.0;
+			T_0 = Vbd_jct / Nvtmd;
+			T1 = lexp(T_0) - 1.0;
 			T2 = IVjdmRev + DslpRev * (Vbd_jct - VjdmRev);
 			Ibd = T1 * T2;
 		end else if (Vbd_jct <= VjdmFwd) begin
-			T0 = Vbd_jct / Nvtmd;
+			T_0 = Vbd_jct / Nvtmd;
 			T1 = (BVD + Vbd_jct) / Nvtmd;
 			T2 = lexp(-T1);
-			Ibd = Isbd * (lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
+			Ibd = Isbd * (lexp(T_0) + XExpBVD - 1.0 - XJBVD * T2);
 		end else
 			Ibd = IVjdmFwd + DslpFwd * (Vbd_jct - VjdmFwd);
 	end else
@@ -3380,34 +3380,34 @@ analog begin
 	//Drain-side junction tunneling current
 	if(JTSD_t > 0.0) begin
 		if((VTSD - Vbd_jct) < (VTSD * 1.0e-3)) begin
-			T0 = -Vbd_jct / Vtm0 / NJTSD_t;
-			T1 = lexp(T0 * 1.0e+3) - 1.0;
+			T_0 = -Vbd_jct / Vtm0 / NJTSD_t;
+			T1 = lexp(T_0 * 1.0e+3) - 1.0;
 			Ibd = Ibd - ADeff * JTSD_t * T1;
 		end else begin
-			T0 = -Vbd_jct / Vtm0 / NJTSD_t;
-			T1 = lexp(T0 * VTSD/ (VTSD - Vbd_jct)) - 1.0;
+			T_0 = -Vbd_jct / Vtm0 / NJTSD_t;
+			T1 = lexp(T_0 * VTSD/ (VTSD - Vbd_jct)) - 1.0;
 			Ibd = Ibd - ADeff * JTSD_t * T1;
 		end
 	end
 	if(JTSSWD_t > 0.0) begin
 		if((VTSSWD - Vbd_jct) < (VTSSWD * 1.0e-3)) begin
-			T0 = -Vbd_jct / Vtm0 / NJTSSWD_t;
-			T1 = lexp(T0 * 1.0e+3) - 1.0;
+			T_0 = -Vbd_jct / Vtm0 / NJTSSWD_t;
+			T1 = lexp(T_0 * 1.0e+3) - 1.0;
 			Ibd = Ibd - PDeff * JTSSWD_t * T1;
 		end else begin
-			T0 = -Vbd_jct / Vtm0 / NJTSSWD_t;
-			T1 = lexp(T0 * VTSSWD / (VTSSWD - Vbd_jct)) - 1.0;
+			T_0 = -Vbd_jct / Vtm0 / NJTSSWD_t;
+			T1 = lexp(T_0 * VTSSWD / (VTSSWD - Vbd_jct)) - 1.0;
 			Ibd = Ibd - PDeff * JTSSWD_t * T1;
 		end
 	end
 	if(JTSSWGD_t > 0.0) begin
 		if((VTSSWGD - Vbd_jct) < (VTSSWGD * 1.0e-3)) begin
-			T0 = -Vbd_jct / Vtm0 / NJTSSWGD_t;
-			T1 = lexp(T0 * 1.0e+3) - 1.0;
+			T_0 = -Vbd_jct / Vtm0 / NJTSSWGD_t;
+			T1 = lexp(T_0 * 1.0e+3) - 1.0;
 			Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
 		end else begin
-			T0 = -Vbd_jct / Vtm0 / NJTSSWGD_t;
-			T1 = lexp(T0 * VTSSWGD / (VTSSWGD - Vbd_jct)) - 1.0;
+			T_0 = -Vbd_jct / Vtm0 / NJTSSWGD_t;
+			T1 = lexp(T_0 * VTSSWGD / (VTSSWGD - Vbd_jct)) - 1.0;
 			Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
 		end
 	end
@@ -3534,8 +3534,8 @@ analog begin
 		if(EM <= 0.0)
 			DelClm = 0.0;
 		else begin
-			T0 = (diffVds / litl + EM) / Esatnoi;
-			DelClm = litl * lln(T0);
+			T_0 = (diffVds / litl + EM) / Esatnoi;
+			DelClm = litl * lln(T_0);
 			if (DelClm < 0.0)  DelClm = 0.0;
 		end
 		T1 = `q * `q * `q * Vt * abs(ids) * ueff;
@@ -3565,8 +3565,8 @@ analog begin
 	I(`IntrinsicDrain,`IntrinsicSource) <+ flicker_noise(FNPowerAt1Hz, EF, "1overf");
 
 `ifdef __TNOISW__
-	T0 = qia/Esatnoi/Leff;
-	T1 = T0 * T0;
+	T_0 = qia/Esatnoi/Leff;
+	T1 = T_0 * T_0;
 	T3 = RNOIA * (1.0 + TNOIA * Leff * T1);
 	T4 = RNOIB * (1.0 + TNOIB * Leff * T1);
 	ctnoi = RNOIC * (1.0 + TNOIC * Leff * T1);
@@ -3579,16 +3579,16 @@ analog begin
 `endif
 		QSi = - NF * Weff * Leff * Cox *Vt * Qs;
 		QDi = - NF * Weff * Leff * Cox *Vt * Qd;
-		T0 = ueff * abs(QSi+QDi);
-		T1 = T0 * Rdsi + Leff * Leff;
-		Gtnoi = (T0 / T1) * NTNOI;
+		T_0 = ueff * abs(QSi+QDi);
+		T1 = T_0 * Rdsi + Leff * Leff;
+		Gtnoi = (T_0 / T1) * NTNOI;
 		sidn = Nt * Gtnoi;
 		I(`IntrinsicDrain, `IntrinsicSource) <+ white_noise(sidn, "id");
 `ifdef __TNOISW__
 	end
 	1: begin
 		Vtn = 2.0 * nq * nVt;
-		T0 = ueff * Dptwg * Moc * Cox * Vtn;
+		T_0 = ueff * Dptwg * Moc * Cox * Vtn;
 		T1 = 0.5 * (qs + qdeff);
 		T3 = T1 + 0.5;
 		T4 = T3 * T3;
@@ -3599,8 +3599,8 @@ analog begin
 		T9 = (6.0 * T1 + 0.5) * T7;
 		Lvsat = Leff * Dptwg;
 		T10 = Lvsat / Leff;
-		mid = T0 * NF * Weff/Lvsat * (T1 + T7/(12.0 * T3)) * 3.0 * betanoisq;
-		mig = Lvsat * T10 * T10 * (T1/T4 - T9/(60.0 * T4 * T4) + T7 * T7/(144.0 * T4 * T5)) * 15.0/4.0 * thetanoisq/(NF * Weff * 12.0 * T0);
+		mid = T_0 * NF * Weff/Lvsat * (T1 + T7/(12.0 * T3)) * 3.0 * betanoisq;
+		mig = Lvsat * T10 * T10 * (T1/T4 - T9/(60.0 * T4 * T4) + T7 * T7/(144.0 * T4 * T5)) * 15.0/4.0 * thetanoisq/(NF * Weff * 12.0 * T_0);
 		migid = T10 * (T6/(12.0 * T3) - T8/(144.0 * T5)) * ctnoi/0.395;
 		sqid =  sqrt(Nt * mid);
 
@@ -3670,12 +3670,12 @@ if (CVMOD==1) begin
 	`Smooth(psip, 1.0, 2.0, psipclamp)
 	sqrtpsip = sqrt(psipclamp);
 	psiavg 	 = psip - 2.0*qs; // source side surf pot.
-	`Smooth(psiavg, 1.0, 2.0, T0)
-	nq 		 = 1.0 + gam / (sqrtpsip + sqrt(T0));
+	`Smooth(psiavg, 1.0, 2.0, T_0)
+	nq 		 = 1.0 + gam / (sqrtpsip + sqrt(T_0));
 
 	// *** Drain Saturation Voltage ***
-	T0 = Vt * (vgfbCV - psip - 2.0*qs*(nq-1.0));
-	`Smooth(T0, 0, 0.1, qbs)
+	T_0 = Vt * (vgfbCV - psip - 2.0*qs*(nq-1.0));
+	`Smooth(T_0, 0, 0.1, qbs)
 	qis = 2.0 * nq * Vt * qs; //Source side qi and qb for Vdsat- normalized to Cox
 
 	Eeffs = EeffFactor * (qbs + eta_mu * qis); // in the unit of MV/cm
@@ -3699,8 +3699,8 @@ if (CVMOD==1) begin
 
 	// Reevaluation of nq to include qdeff --needed for gummel symmetry
 	psiavg = psip - qs - qdeff -1.0;
-	`Smooth(psiavg, 1.0, 2.0, T0)
-	T2 = sqrt(T0);
+	`Smooth(psiavg, 1.0, 2.0, T_0)
+	T2 = sqrt(T_0);
 	T3 = 1.0 + DPD + gam/(sqrtpsip+T2);
 	T4 = 0.5 + DPD*T2*inv_gam;
 	T5 = sqrt( T4*T4 + T3*(qs+qdeff)*invgamg2);
@@ -3710,8 +3710,8 @@ if (CVMOD==1) begin
 	//CV Expressions including Velocity Saturation and CLM
 	//*********************************************************
 	// --- Velocity Saturation for CV ---
-	T0 = Vt * (vgfbCV - psip - 2.0*qs*(nq-1.0));
-	`Smooth(T0, 0, 0.1, qbs)
+	T_0 = Vt * (vgfbCV - psip - 2.0*qs*(nq-1.0));
+	`Smooth(T_0, 0, 0.1, qbs)
 	T1 = Vt * (vgfbCV - psip - 2.0*qdeff*(nq-1.0));
 	`Smooth(T1, 0, 0.1, qbd)
 	qb = 0.5*(qbs+qbd);
@@ -3778,8 +3778,8 @@ end
 	`Smooth(Vt*Qb, 0, 0.1, qbaCV)
 	qiaCV = Vt*( Qs + Qd);
 
-	T0 = (qiaCV + ETAQM * qbaCV) / QM0;
-	T1 = 1.0 + pow(T0, 0.7*BDOS);
+	T_0 = (qiaCV + ETAQM * qbaCV) / QM0;
+	T1 = 1.0 + pow(T_0, 0.7*BDOS);
 	XDCinv = ADOS * 1.9e-9 / T1;
 
 	Coxeffinv = 3.9 * `EPS0 / (BSIM6TOXP * 3.9 / EPSROX + XDCinv / epsratio);
@@ -3803,13 +3803,13 @@ end
 		Qovs	= -Wact*NF*Cgsof*Vgs_ov_noswap;
 		Qovd	= -Wact*NF*Cgdof*Vgd_ov_noswap;
 	end else begin
-		T0 		= sqrt((Vgs_ov_noswap -Vfbsdr + `DELTA_1)*(Vgs_ov_noswap -Vfbsdr + `DELTA_1) +4.0 * `DELTA_1);
-		Vgsov	= 0.5*(Vgs_ov_noswap -Vfbsdr + `DELTA_1 - T0);
+		T_0 		= sqrt((Vgs_ov_noswap -Vfbsdr + `DELTA_1)*(Vgs_ov_noswap -Vfbsdr + `DELTA_1) +4.0 * `DELTA_1);
+		Vgsov	= 0.5*(Vgs_ov_noswap -Vfbsdr + `DELTA_1 - T_0);
 		T1		= sqrt(1.0 - 4.0*Vgsov/CKAPPAS_i);
 		Qovs	= -Wact*NF*( Cgsof*Vgs_ov_noswap + CGSL_i*( Vgs_ov_noswap -Vfbsdr - Vgsov - 0.5*CKAPPAS_i*(-1.0 + T1)));
 
-		T0		= sqrt((Vgd_ov_noswap -Vfbsdr + `DELTA_1)*(Vgd_ov_noswap -Vfbsdr + `DELTA_1) +4.0 * `DELTA_1);
-		Vgdov	= 0.5*(Vgd_ov_noswap -Vfbsdr + `DELTA_1 - T0);
+		T_0		= sqrt((Vgd_ov_noswap -Vfbsdr + `DELTA_1)*(Vgd_ov_noswap -Vfbsdr + `DELTA_1) +4.0 * `DELTA_1);
+		Vgdov	= 0.5*(Vgd_ov_noswap -Vfbsdr + `DELTA_1 - T_0);
 		T2		= sqrt(1.0 - 4.0*Vgdov/CKAPPAD_i);
 		Qovd	= -Wact*NF*( Cgdof*Vgd_ov_noswap + CGDL_i*( Vgd_ov_noswap -Vfbsdr - Vgdov - 0.5*CKAPPAD_i*(-1.0 + T2)));
 	end
-- 
2.1.2

